---
title: "CUBAN MIGRATION ANALYSIS"
author: "Gabriel Hernandez"
date: "2024-03-21"
output: html_document
---
```{r}
#
 #knitr::opts_chunk$set(
 # comment = "#>", echo = FALSE, fig.width = 6
#)


#figure settings 
fig_small <- FALSE  # Change to TRUE for smaller figures, FALSE for larger
width_small <- 4    # Width in inches for small figures
width_large <- 8    # Width in inches for large figures
```



```{r install packages, echo=FALSE, message=FALSE, warning=FALSE}

library(tidyverse)
library(classInt)
library(patchwork)
library(mapview)
library(tidycensus)
library(sf)
library(dplyr)
library(kableExtra)
library(osmdata)
library(ggforce)
library(tigris)
library(flexdashboard)
#library(scales)
library(shiny)
library(stringr)
library(Hmisc)
library(DAAG)
library(car)  #to calculate VIF
library(MASS)
library(rsq)
library(tidyverse)
library(caret)
library(dplyr)


options(scipen=999)
options(tigris_class = "sf")
options(tigris_cache_dir= TRUE)

source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

#Load API KEY
census_api_key("3aedcfd189958d66a813a29a4b33580e78657644", overwrite = TRUE)
#Set CRS
crs='EPSG:3857'


```
# Introduction


#Data Wrangling

In order to perform the exploratory analysis I will use tidycensus to get data and its associated geometries. I will be operating on three scales: core-based areas, counties, and census tracts. It is important at this point to note that the the Census defines 'foreign-born' populations as 'anyone who is not a U.S. citizen at birth, including those who become U.S. citizens through naturalization.' The subtopics discuss the different scales used in the analysis.

Below are lists of variables for 2009 and 2022 ACS 5-Year Estimates. The codes differ between years so they were created from carefully reading load_variable() outputs and filtering on R Studios interacive view() output. 

```{r ACS LOAD VARIABLES, echo=FALSE}
# vars for 2009 and 2022 for change over time comparison

acs_variable_list.2009 <- load_variables(2009, #year
                                         "acs5", #five year ACS estimates
                                         cache = TRUE)

acs09_vars <- c("B06003_013E", #Foreign Born - PLACE OF BIRTH BY SEX IN THE UNITED STATES
              "B05002_013E", #Estimate!!Total!!Foreign born - PLACE OF BIRTH BY CITIZENSHIP STATUS
              "B05007_039E", #Estimate!!Total!!Latin America!!Caribbean!!- Entered before 1980
              "B25002_003E", #stimate!!Total!!Vacant OCCUPANCY STATUS
              "B09016_002E", #Estimate!!Total!!In households - HOUSEHOLD TYPE (INCLUDING LIVING ALONE) BY RELATIONSHIP
              "B19013_001E", #Estimate!!Median household income in the past 12 months (in 2009 inflation-adjusted dollars)
              "B19037A_053E", #Estimate!!Total!!Householder 65 years and over
              "B06012_002E", #Total!!Below 100 percent of the poverty level
              "B25071_001E", #Median gross rent as a percentage of household income
              "B25035_001E", #Median year structure built
              "B19057_001E", #Total - PUBLIC ASSISTANCE INCOME IN THE PAST 12 MONTHS FOR HOUSEHOLDS
              "B25001_001E", #Total HOUSING UNITS
              "B05006_127E", #Total!!Americas!!Latin America!!Caribbean!!Cuba
              "B25077_001E") #med values

acs22load <- load_variables(2022, "acs5", cache = TRUE)
acs22_vars <-c("B06012PR_002E", #Tot Below 100 percent of the poverty level
               "B25002_003E", #TotalVacant
               "B21004_001E", #Median income in the past 12 months (in 2022 inflation-adjusted dollars
               "B09021_023E", #65 years and over Lives alone
               "B25136_001E", #Total Housing Units
               "B25071_001E", #Median gross rent as a percentage of household income
               "B05006_143E", #Total:!!Americas:!!Latin America:!!Caribbean:!!Cuba
               "B19057_002E", #Total:!!With public assistance income
               "B25035_001E", #Median year structure built
               "B25077_001E" #med values
       )



```
## Core-Based Statistical Areas: ACS 5-Year Estimates 2022

A metropolitan or micropolitan statistical area contains a core area with a substantial population nucleus, as well as adjacent communities having a high degree of economic and social integration with that core. Core Based Statistical Area (CBSA) term became effective in 2000 and refers collectively to metropolitan and micropolitan statistical areas.Each metropolitan statistical area must have one urbanized area of 50,000 or more inhabitants. Each micropolitan statistical area must have one urban cluster of 10,000 to 49,999 inhabitants

The first call is to get the core-based statistical areas across the United States using ACS 5- Year Estimates for 2022, to observe the count of foreign-born Cubans in each area as well as other variables that I was interested in. 

I then filter the data frame that it creates in different ways to create subsets that provide context to the existing presence of Cuban migrants. First, I isolate metro and micro statistical areas, as they are both returned in the call. I use filter() on metro areas to get those that have 1000+ foreign born cubans, and 100+ for micro areas. Lastly, because the majority of the Cuban migration is related to Florida, I further filtered the USA_metro and USA_micro objects to those that are in Florida and outside of it. I believe this will provide more unknown context to the general story of Cuban Migration. 

```{r}

#get variables in core_based_statistical areas across USA

USA_allcba <- get_acs(geography = "metropolitan statistical area/micropolitan statistical area",
                             year = 2022, 
                             variables = acs22_vars, 
                             geometry = TRUE, 
                             output = "wide") 

#Rename the variables for the 2022 data
USA_allcba <- USA_allcba %>%
         rename(total_below_pov=B06012PR_002E,
         tot_vacant22 = B25002_003E,
         med_inc22 = B21004_001E,
         up65_alone22 = B09021_023E,
         tot_housingunits22 =B25136_001E,
         gross_v_inc_perc22 = B25071_001E,
         tot_fb_cuba22 = B05006_143E,
         tot_pa_inc22 = B19057_002E,
         med_yb22 = B25035_001E,
         med_values22 = B25077_001E)%>%
  mutate(vacpct22 = (tot_vacant22/tot_housingunits22)) %>%
  st_as_sf(crs = crs)

#Begin filtering
USA_micros <- USA_allcba %>%
              filter(grepl("Micro", NAME, ignore.case = TRUE)) %>%
              select(NAME, GEOID,tot_housingunits22,gross_v_inc_perc22,tot_fb_cuba22,med_yb22, vacpct22) %>%
              filter(tot_fb_cuba22 >= 100)%>%
              arrange(desc(tot_fb_cuba22))

USA_metros <- USA_allcba %>%
              filter(grepl("Metro", NAME, ignore.case=TRUE)) %>%
              select(NAME, GEOID,tot_housingunits22,gross_v_inc_perc22,tot_fb_cuba22,med_yb22, vacpct22) %>%
              filter(tot_fb_cuba22 >= 1000)%>%
              arrange(desc(tot_fb_cuba22))

#create final objects for kable tables
noFL_micros <- USA_micros %>%
              filter(!grepl("FL M", NAME, ignore.case = TRUE)) 
            

noFL_metros <-USA_metros %>%
              filter(!grepl("FL M" , NAME, ignore.case= TRUE))

fl_micros <- USA_micros %>%
             filter(grepl("FL M", NAME, ignore.case = TRUE)) 
            

fl_metros <-USA_metros %>%
            filter(grepl("FL M" , NAME, ignore.case= TRUE))
            

```
## County Data and Calculating Change over Time

to get the data we need on foreign-born cubans at the county level in order to identify, outside of florida, what are the counties with the current highest concentration of foreign-born Cubans. I will also use tigris to get an sf object of "places" in the united states. The goal is to identify counties of interest and create an sf object from intersecting those counties and the places object of all cities in the United states.

Furthermore, at the end of the county-level analysis, a call will be made to tigris to get the census tracts for the counties of interest in order to join them to the dataframe with the change-over-time values. THis will be for the main visualization: an interactive map that displays first the location of counties of interest and then upon zooming in, the boundaries of the places that they are in and the census tract level data displaying where in the counties the cuban communities are relative to the city boundaries. (relate this to theory about settlement patterns of immigrants). 
```{r}

USA_2009 <- get_acs(geography = "county",
                             year = 2009, 
                             variables = acs09_vars,
                             geometry = TRUE, 
                             output = "wide") 
USA_2009 <- USA_2009 %>%
          rename(
          fb_placebysex.2009 = B06003_013E,
          totalfb_placebycitizenshipstatus.2009 = B05002_013E,
          total_carib_1980.2009 = B05007_039E,
          total_vacancy_O_status.2009 = B25002_003E,
          total_householdtype_relationship.09 = B09016_002E,
          med_hh_inc.09 = B19013_001E,
          hh_65up.09 = B19037A_053E,
          Total_b_100pov.09 = B06012_002E,
          gross_v_income_percentage.09 = B25071_001E,
          med_built_year.09 = B25035_001E,
          tot_publicass_inc.09 = B19057_001E,
          tot_housingunits.09 = B25001_001E,
          cub_fb_total09 = B05006_127E,
          med_houseval09 = B25077_001E
          )%>%
          mutate(vacancyPct.2009 = total_vacancy_O_status.2009/tot_housingunits.09) %>% # Get Vacanct Rate
          st_as_sf(crs = crs)

USA_2022 <- get_acs(geography = "county",
                             year = 2022, 
                             variables = acs22_vars, 
                             geometry = TRUE, 
                             output = "wide") 
USA_2022 <- USA_2022 %>%
         rename(
         tot_below100pov22 = B06012PR_002E,
         tot_vacant22 = B25002_003E,
         med_inc22 = B21004_001E,
         up65_alone22 = B09021_023E,
         tot_housingunits22 =B25136_001E,
         gross_v_inc_perc22 = B25071_001E,
         tot_fb_cuba22 = B05006_143E,
         tot_pa_inc22 = B19057_002E,
         med_yb22 = B25035_001E,
         med_values22 = B25077_001E)%>%
  mutate(vacpct22 = (tot_vacant22/tot_housingunits22)) %>%
  st_as_sf(crs = crs)

#Merge the dataframes

USA0922_df <- st_drop_geometry(USA_2022,USA_2009)%>%
         left_join(USA_2009 , USA_2022, by= c("GEOID"))%>%
         mutate(change_vac_pct = vacpct22 - vacancyPct.2009,
           change_med_inc = med_inc22 - med_hh_inc.09,
           change_med_values = med_values22 - med_houseval09,
           change_count_housingunits= tot_housingunits22-tot_housingunits.09,
           change_cuba_fb = tot_fb_cuba22 - cub_fb_total09,
           change_pct_below100pov = tot_below100pov22 - Total_b_100pov.09)

#Begin Filtering Process

##decrease
USA0922_df_filtered_decrease <- USA0922_df %>%
              filter(change_cuba_fb < -500)%>%
              select(NAME.x, GEOID, geometry,cub_fb_total09, med_inc22,up65_alone22, tot_housingunits22,   gross_v_inc_perc22, change_count_housingunits, tot_pa_inc22,med_values22, vacpct22, change_med_values,change_cuba_fb, change_med_inc,                         change_vac_pct)

##increase
USA0922_df_filtered_increase <- USA0922_df %>% 
       filter(change_cuba_fb > 500) %>%
       select(NAME.x, GEOID, geometry, med_inc22,up65_alone22,cub_fb_total09, tot_housingunits22, gross_v_inc_perc22,   change_count_housingunits,                              tot_pa_inc22,med_values22, vacpct22, change_med_values, change_med_inc,                         change_vac_pct,change_cuba_fb)
  
#Combine the two dfs to create the filtered all counties object for the census tract level pull

change_fbcuban0922<- rbind(USA0922_df_filtered_decrease, USA0922_df_filtered_increase)%>%
  st_as_sf(crs = crs)





```



Upon analyzing the counties, choose filters to get the most increasing and decreasing populations. Get the ID of each of these counties in a way so we can intersect the USA_allcba object to get the geometries of only the metro and micro areas that are within the chosen counties.

We also have to iterate those counties over a function that gets all the census tract level data for the county. Once we have these object, the next step will be to figure out how to classify the data so it can make nice visuals!!!

Will spend this weekend doing literature review to be able to supplement the observations. 


```{r}
#=============================
#Create function that creates a dictionary that has the state county combination to ask for the tract level data
#===============================

split_county_state <- function(name) {
  # Split the string on the comma to separate county and state
  parts <- str_split(name, pattern = ",", n = 2, simplify = TRUE)
  county <- trimws(parts[1])
  state <- trimws(parts[2])

  return(list(county = county, state = state))
}

clean_county_name <- function(county_name) {
  # Remove 'County' from the end of the string and any leading/trailing spaces
  cleaned_name <- sub("County$", "", county_name)
  cleaned_name <- trimws(cleaned_name)
  return(cleaned_name)
}

#to visualize per state grouping, do I need to use tigris to get the geometries for each state then merge it with a group by state function?
```


```{r}

change_fbcuban0922_split <- change_fbcuban0922 %>%
  mutate(
    split_data = map(NAME.x, split_county_state),
    County = map_chr(split_data, "county"),
    State = map_chr(split_data, "state")
  ) %>%
  select(-split_data)%>%
  mutate(cleaned_County = sapply(County, clean_county_name))# Remove the list column after extracting components

```


```{r}
iterate_county22 <- function(df) {
  # List to store the results
  results_list <- list()

  # Loop over each row of the dataframe
  for (i in 1:nrow(df)) {
    # Extract county and state from the current row
    County <- df$cleaned_County[i]
    State <- df$State[i]
    
    # Try to fetch ACS data, handling errors
    acs_data <- tryCatch({
      get_acs(
        geography = "tract",  # Make sure geography is correctly specified
        variables = "B05006_143E",  # Example variable: Total Population
        state = State,
        county = County,
        year = 2022,
        survey = "acs5",
        geometry = TRUE
      )
    }, error = function(e) {
      message("Failed for ", County, ", ", State, ": ", e$message)
      NULL  # Return NULL on failure
    })
    
    # Append the fetched data to the list, if not NULL
    if (!is.null(acs_data)) {
      results_list[[length(results_list) + 1]] <- acs_data
    }
  }

  # Combine all the results into one data frame
  final_data <- bind_rows(results_list)
  return(final_data)
}

iterate_county09 <- function(df) {
  # List to store the results
  results_list <- list()

  # Loop over each row of the dataframe
  for (i in 1:nrow(df)) {
    # Extract county and state from the current row
    County <- df$cleaned_County[i]
    State <- df$State[i]
    
    # Try to fetch ACS data, handling errors
    acs_data <- tryCatch({
      get_acs(
        geography = "tract",  # Make sure geography is correctly specified
        variables = "B05006_127E",  # Example variable: Total Population
        state = State,
        county = County,
        year = 2009,
        survey = "acs5",
        geometry = TRUE
      )
    }, error = function(e) {
      message("Failed for ", County, ", ", State, ": ", e$message)
      NULL  # Return NULL on failure
    })
    
    # Append the fetched data to the list, if not NULL
    if (!is.null(acs_data)) {
      results_list[[length(results_list) + 1]] <- acs_data
    }
  }

  # Combine all the results into one data frame
  final_data <- bind_rows(results_list)
  return(final_data)
}

```

```{r , results='hide', message=FALSE, warning= FALSE}

final_acs09_data <- iterate_county09(change_fbcuban0922_split)
final_acs22_data <- iterate_county22(change_fbcuban0922_split)
```

```{r}

#wrangle the data a bit to get the change over time at the census tract level
final_acs09_data<-final_acs09_data %>%
                  rename(cub_fb_total09 = estimate)

final_acs22_data<- final_acs22_data %>%
                  rename(tot_fb_cuba22 = estimate)

final_viz_change <- st_drop_geometry(final_acs09_data) %>%
  select(GEOID, cub_fb_total09) %>%  # Select only the columns needed for computing change
  left_join(final_acs22_data, by = "GEOID") %>%
  mutate(change_cuba_fb = tot_fb_cuba22 - cub_fb_total09)

#dropNA values in change
final_viz_change_droppedNA <- final_viz_change[!is.na(final_viz_change$change_cuba_fb), ]

final_viz_change_droppedNA<- final_viz_change_droppedNA%>%
                             st_as_sf(sf_column_name='geometry')
```


```{r}
#we are going to intercect all metro and micro areas with the selected counties object 'change_fbcuban0922'


metro_micro_boundaries_final <-USA_allcba%>%
                     
                     st_as_sf()%>%
                     st_transform(st_crs(change_fbcuban0922))
                     st_intersection(change_fbcuban0922)


#sf_column_name='geometry'

```
```{r}
# Install (if necessary) and load the tmap package
if (!requireNamespace("tmap", quietly = TRUE)) {
    install.packages("tmap")
}
library(tmap)

tmap_options(check.and.fix = TRUE)

# Set tmap mode to interactive viewing
tmap_mode("view")


# Calculate natural breaks for the 'pop_est' variable
#num_categories = 5  # Define the number of categories or breaks you want
#breaks_natural = classIntervals(final_viz_change_droppedNA$change_cuba_fb, n = num_categories, style = "jenks")$brks



# Create the map
tm <- tm_shape(final_viz_change_droppedNA) +  # Adds the 'final' object
      tm_polygons("change_cuba_fb", breaks = c(-1015, -500,0, 500, 1847), title = "Change in Count of Foreign Born Cubans", 
                  palette = "-RdYlBu",  # Color palette  
                  border.col = "black",  # Border color for polygons in 'final'
                  border.alpha = 0.3)+# Border transparency
      tm_basemap("Esri.WorldStreetMap")
    


# Print the map
tm

#tm_tip(c("change_cuba_fb", "other_attribute1", "other_attribute2"), labels = c("Change FB:", "Attribute 1:", "Attribute 2:"))  # Tooltips showing attributes

```
